import pandas as pd
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_absolute_error, r2_score

# Cargar los datos
data_path = 'D:/_Curso Inteligencia Artificial/BuildingAI/NBancoAlimentos.csv'
data = pd.read_csv(data_path)

# Preparar los datos
X = data.drop('ad01', axis=1)  # Variables independientes
y = data['ad01']  # Variable dependiente

# Codificación one-hot para variables categóricas y passthrough para numéricas
preprocessor = ColumnTransformer(
    transformers=[
        ('cat', OneHotEncoder(handle_unknown='ignore'), ['barriada', 'campana'])
    ], remainder='passthrough')

# Crear un pipeline con preprocesamiento y modelo de regresión
model_pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('regressor', LinearRegression())
])

# Dividir los datos asegurando que todos los grupos de 'campana' están representados en el conjunto de prueba
# Esto se hace para capturar la variabilidad anual y la particularidad de la campaña de invierno o Navidad
# Como 'campana' es una variable categórica, usaremos un enfoque para dividir que mantenga la proporción de cada categoría

# Dividir los datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=X['campana'], random_state=42)

# Ajustar el modelo
model_pipeline.fit(X_train, y_train)

# Realizar predicciones en el conjunto de prueba
y_pred = model_pipeline.predict(X_test)

# Calcular y mostrar el MSE
mse = mean_squared_error(y_test, y_pred)
print(f'MSE: {mse}')

# Error Absoluto Medio (MAE)
mae = mean_absolute_error(y_test, y_pred)

# Coeficiente de Determinación (R^2)
r2 = r2_score(y_test, y_pred)

print(f'MAE: {mae}')
print(f'R^2: {r2}')

# Calcula el mínimo y el máximo de la variable dependiente 'ad01'
ad01_min = data['ad01'].min()
ad01_max = data['ad01'].max()

# Calcula el rango (diferencia entre el máximo y el mínimo)
ad01_range = ad01_max - ad01_min

# Calcula la media de 'ad01'
ad01_mean = data['ad01'].mean()

print(f"Min: {ad01_min}, Max: {ad01_max}, Rango: {ad01_range}, Media: {ad01_mean}")
